<!DOCTYPE html>
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ¨æ€æ–‡ç« ç”Ÿæˆå·¥å…· (å­—æ•°ç»Ÿè®¡/å‹¾é€‰çŠ¶æ€ä¿å­˜/æ‹–æ‹½æ’åº/åŒå‡»æ”¹é€Ÿç‡/å¤åˆ¶çº¯æ–‡æœ¬/ä¸‹è½½å¯¼å…¥TXT)</title> <!-- Updated Title -->
    <style>
        /* --- Base Styles --- */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; padding: 20px; background-color: #f8f9fa; color: #212529; }
        .container { max-width: 750px; margin: 20px auto; background: #fff; padding: 25px 35px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); border: 1px solid #dee2e6; }
        h1 { color: #343a40; text-align: center; margin-bottom: 15px; font-weight: 600; }
        .description { text-align: center; color: #6c757d; margin-bottom: 30px; font-size: 0.95em; }
        .input-fields { margin-bottom: 25px; padding-bottom: 10px; }
        .input-group { margin-bottom: 18px; padding: 15px; border: 1px solid #e9ecef; border-radius: 6px; background-color: #fff; position: relative; display: flex; flex-direction: column;
            transition: box-shadow 0.2s ease-in-out, opacity 0.2s ease-in-out, transform 0.2s ease-in-out, border-color 0.2s ease-in-out;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
         }
        .input-group:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
        .input-group-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; gap: 10px; cursor: grab; }
        .input-group-header:active { cursor: grabbing; }

        label.editable-label { font-weight: 600; color: #495057; font-size: 0.95em; cursor: text; padding: 3px 6px; border-radius: 4px; transition: background-color 0.2s ease, box-shadow 0.2s ease; flex-grow: 1; word-break: break-word; line-height: 1.4; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; min-width: 50px; }
        label.editable-label:hover { background-color: #f1f3f5; }
        label.editable-label:focus, label.editable-label[contenteditable="true"] { background-color: #e7f5ff; outline: none; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2); cursor: text !important; }
        textarea.input-box { padding: 12px; border: 1px solid #ced4da; border-radius: 4px; font-size: 1em; min-height: 55px; resize: vertical; box-sizing: border-box; width: 100%; transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; cursor: text; }
        textarea.input-box:focus { border-color: #86b7fe; outline: 0; box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25); }
        .input-group-buttons { display: flex; align-items: center; gap: 6px; flex-shrink: 0; cursor: auto; }
        .include-checkbox-label { display: flex; align-items: center; cursor: pointer; margin-right: 4px; padding: 2px; border-radius: 3px; }
        .include-checkbox-label input[type="checkbox"] { margin: 0; width: 16px; height: 16px; cursor: pointer; accent-color: #0d6efd; vertical-align: middle; }
        .include-checkbox-label:hover { background-color: #f1f3f5; }
        button.action-icon-btn { color: white; border: none; border-radius: 50%; width: 26px; height: 26px; font-size: 18px; font-weight: bold; line-height: 26px; text-align: center; cursor: pointer; padding: 0; transition: background-color 0.2s ease, transform 0.1s ease; display: flex; align-items: center; justify-content: center; }
        button.action-icon-btn:hover { transform: scale(1.1); }
        button.action-icon-btn:active { transform: scale(1); }
        button.insert-btn { background-color: #198754; }
        button.insert-btn:hover { background-color: #157347; }
        button.delete-btn { background-color: #e63946; }
        button.delete-btn:hover { background-color: #d62828; }
        #add-field-btn { display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%; padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; font-weight: 500; margin-top: 20px; transition: background-color 0.3s ease; }
        #add-field-btn::before { content: '+'; font-size: 1.2em; line-height: 1; }
        #add-field-btn:hover { background-color: #0056b3; }
        .action-button-group { display: flex; justify-content: center; gap: 15px; margin-top: 25px; margin-bottom: 30px; flex-wrap: wrap; }
        .action-button-group button { padding: 12px 25px; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1.05em; font-weight: 500; transition: background-color 0.3s ease, opacity 0.3s ease; display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        .action-button-group button:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.65; }
        #copy-btn { background-color: #28a745; }
        #copy-btn::before { content: 'ğŸ“‹'; font-size: 1.1em; }
        #copy-btn:hover:not(:disabled) { background-color: #218838; }
        #copy-btn.copied { background-color: #198754; }
        #copy-btn.copied::before { content: 'âœ…'; }
        #download-txt-btn { background-color: #fd7e14; }
        #download-txt-btn::before { content: 'ğŸ’¾'; font-size: 1.1em; }
        #download-txt-btn:hover:not(:disabled) { background-color: #e66800; }
        #import-txt-btn { background-color: #6f42c1; }
        #import-txt-btn::before { content: 'ğŸ“¤'; font-size: 1.1em; }
        #import-txt-btn:hover:not(:disabled) { background-color: #59359a; }

        .output-section { margin-top: 20px; }
        #output-label { font-weight: 600; color: #343a40; display: block; margin-bottom: 8px; font-size: 1.1em; }
        #output-stats { font-size: 0.88em; color: #6c757d; margin-bottom: 10px; line-height: 1.8; padding-left: 5px; }
        .stat-item { display: inline-block; margin-right: 15px; white-space: nowrap; margin-bottom: 5px; }
        .stat-item:last-child { margin-right: 0; }
        .stat-value { font-weight: bold; color: #495057; }
        .stat-item-hanzi .stat-value { color: #dc3545; }
        .stat-item-punct .stat-value { color: #0dcaf0; }
        .stat-item-letter .stat-value { color: #198754; }
        .stat-item-digit .stat-value { color: #ffc107; }
        .stat-item-time .stat-value { color: #6f42c1; }
        #stats-rate-value { display: inline-block; font-weight: bold; color: #6f42c1; cursor: text; padding: 1px 4px; border-radius: 3px; transition: background-color 0.2s ease, box-shadow 0.2s ease; min-width: 25px; text-align: center; }
        #stats-rate-value:hover { background-color: #f1f3f5; }
        #stats-rate-value:focus { background-color: #e7f5ff; outline: none; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2); }
        .output-area-div { width: 100%; min-height: 200px; padding: 15px; border: 1px solid #ced4da; background-color: #f8f9fa; border-radius: 6px; font-size: 1em; line-height: 1.7; box-sizing: border-box; white-space: pre-wrap; overflow-wrap: break-word; transition: background-color 0.3s ease, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; color: #495057; display: block; margin-top: 0; overflow-y: auto; }
        .output-area-div:focus { border-color: #86b7fe; outline: 0; box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25); background-color: #fff; }
        .output-area-div strong { font-weight: 700; color: #343a40; margin-right: 0.3em; }
        .output-area-div .empty-message { text-align: center; color: #6c757d; padding: 20px 0; font-style: italic; width: 100%; font-weight: normal; }
        .output-area-div > div:not(.empty-message) { margin-bottom: 0.2em; }
        .output-area-div > div:last-child { margin-bottom: 0; }
        .empty-message { text-align: center; color: #6c757d; padding: 20px 0; font-style: italic; }

        /* --- Drag and Drop Styles --- */
        .input-group.dragging {
            opacity: 0.5; border: 2px dashed #007bff; background-color: #e7f5ff; box-shadow: 0 8px 16px rgba(0,0,0,0.15);
        }
        .input-group.drag-over-indicator {
            border-top: 3px solid #0dcaf0; margin-top: 5px; margin-bottom: calc(18px + 5px);
        }
        .input-group-buttons, .input-group-buttons *, textarea.input-box, label.editable-label[contenteditable="true"], label.editable-label:focus, .include-checkbox-label, .include-checkbox-label input {
            cursor: auto; -webkit-user-drag: none; user-drag: none; -moz-user-select: text; -webkit-user-select: text; -ms-user-select: text; user-select: text;
        }
         ::selection { background: #b3d4fc; }
        ::-moz-selection { background: #b3d4fc; }

        /* Style for temporary textarea used by fallback copy */
        .copy-fallback-textarea {
            position: fixed; /* Or absolute */
            top: -9999px;
            left: -9999px;
            opacity: 0;
            pointer-events: none;
            z-index: -1; /* Ensure it's behind everything */
            width: 10px; /* Minimal size */
            height: 10px;
        }

    </style>
</head>
<body>

<div class="container">
    <h1>åŠ¨æ€æ–‡ç« ç”Ÿæˆå·¥å…·</h1>
    <p class="description">è¾“å…¥å†…å®¹å®æ—¶ç”Ÿæˆå¸¦æ ‡ç­¾é¢„è§ˆ (å¯<strong>å‹¾é€‰</strong>æ˜¯å¦è¾“å‡º, <strong style="color: #dc3545;">æ— å†…å®¹ä¸æ˜¾ç¤º</strong>)ã€‚å¯ä¿®æ”¹æ ‡ç­¾ã€æ’å…¥/åˆ é™¤æ¡ç›®ã€<strong>æ‹–æ‹½æ’åº</strong>ã€‚<strong>å¤åˆ¶æŒ‰é’®ä»…å¤åˆ¶å‹¾é€‰æ¡ç›®çš„çº¯æ–‡æœ¬ã€‚</strong> æ–°å¢ <strong>ä¸‹è½½ TXT</strong> æŒ‰é’®å¯ä¿å­˜æ‰€æœ‰æ ‡ç­¾ã€å†…å®¹åŠå‹¾é€‰çŠ¶æ€ (æœªå‹¾é€‰ç”¨ `[ ] ` æ ‡è®°), <strong>å¯¼å…¥ TXT</strong> å¯æ¢å¤æ•°æ®åŠå‹¾é€‰çŠ¶æ€ã€‚å®æ—¶å­—æ•°ç»Ÿè®¡ã€å£æ’­æ—¶é•¿ä¼°ç®—ï¼ˆ<strong title="åŒå‡»ä¸‹æ–¹æ‹¬å·é‡Œçš„æ•°å­—å³å¯ä¿®æ”¹">é€Ÿç‡å¯è°ƒ</strong>ï¼‰æ˜¾ç¤ºåœ¨é¢„è§ˆåŒºä¸Šæ–¹ã€‚</p> <!-- Updated Description -->

    <div id="input-fields" class="input-fields">
        <!-- Input fields will be generated here by JS -->
    </div>

    <button id="add-field-btn">æ·»åŠ æ–°æ¡ç›®åˆ°æœ«å°¾</button>

    <div class="action-button-group">
        <button id="copy-btn" disabled="">å¤åˆ¶æ–‡ç« </button>
        <button id="download-txt-btn" disabled="">ä¸‹è½½ TXT</button>
        <button id="import-txt-btn">å¯¼å…¥ TXT</button>
    </div>
    <input type="file" id="import-file-input" accept=".txt" style="display: none;">

    <div class="output-section">
        <label for="output-area" id="output-label">ç”Ÿæˆçš„æ–‡ç«  (é¢„è§ˆåŒºä»…æ˜¾ç¤ºå‹¾é€‰ä¸”æœ‰å†…å®¹çš„æ¡ç›®):</label>
        <div id="output-stats">
             <span class="stat-item stat-item-total">æ€»å­—æ•°(å‹¾é€‰æœ‰å†…å®¹): <span class="stat-value" id="stats-total">0</span></span>
             <span class="stat-item stat-item-hanzi">æ±‰å­—(å‹¾é€‰æœ‰å†…å®¹): <span class="stat-value" id="stats-hanzi">0</span></span>
             <span class="stat-item stat-item-punct">æ ‡ç‚¹(å…¨è§’)(å‹¾é€‰æœ‰å†…å®¹): <span class="stat-value" id="stats-biaodian">0</span></span>
             <span class="stat-item stat-item-letter">å­—æ¯/ç¬¦(åŠè§’)(å‹¾é€‰æœ‰å†…å®¹): <span class="stat-value" id="stats-zimu">0</span></span>
             <span class="stat-item stat-item-digit">æ•°å­—(å‹¾é€‰æœ‰å†…å®¹): <span class="stat-value" id="stats-shuzi">0</span></span>
             <br>
             <span class="stat-item stat-item-time">
                 å£æ’­æ—¶é•¿(<span id="stats-rate-value" contenteditable="false" title="åŒå‡»ä¿®æ”¹é€Ÿç‡ (50-1000)">300</span>å­—/åˆ†é’Ÿ):
                 <span class="stat-value" id="stats-time">0åˆ†0ç§’</span>
             </span>
        </div>
        <div id="output-area" class="output-area-div" role="textbox" aria-readonly="true" aria-labelledby="output-label">
             <!-- Content will be added by JS -->
        </div>
    </div>

</div>

<script>
    // DOM Elements (unchanged)
    const inputFieldsContainer = document.getElementById('input-fields');
    const addFieldBtn = document.getElementById('add-field-btn');
    const copyBtn = document.getElementById('copy-btn');
    const downloadTxtBtn = document.getElementById('download-txt-btn');
    const importTxtBtn = document.getElementById('import-txt-btn');
    const importFileInput = document.getElementById('import-file-input');
    const outputArea = document.getElementById('output-area');
    const statsTotalEl = document.getElementById('stats-total');
    const statsHanziEl = document.getElementById('stats-hanzi');
    const statsBiaodianEl = document.getElementById('stats-biaodian');
    const statsZimuEl = document.getElementById('stats-zimu');
    const statsShuziEl = document.getElementById('stats-shuzi');
    const statsRateValueEl = document.getElementById('stats-rate-value');
    const statsTimeEl = document.getElementById('stats-time');

    // Constants and State (unchanged)
    const localStorageDataKey = 'dynamicArticleGeneratorData_v8';
    const defaultItemLabelPrefix = "æ–°æ¡ç›® ";
    const DEFAULT_SPEAKING_RATE = 300;
    const MIN_SPEAKING_RATE = 50;
    const MAX_SPEAKING_RATE = 1000;
    const UNCHECKED_ITEM_PREFIX = "[ ] ";
    let inputFieldsData = [];
    let nextId = 1;
    let speakingRate = DEFAULT_SPEAKING_RATE;
    let draggedItemId = null;
    let saveTimeout;

    // --- Helper Function: Escape HTML --- (unchanged)
    function escapeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    // --- Helper Functions (getNextDefaultItemNumber) --- (unchanged)
    function getNextDefaultItemNumber(currentFieldsData) {
        let maxNum = 0;
        const regex = new RegExp(`^${defaultItemLabelPrefix.trim()}\\s*(\\d+):?$`, 'i');
        currentFieldsData.forEach(field => {
            const match = field.label.match(regex);
            if (match && match[1]) {
                const num = parseInt(match[1], 10);
                if (!isNaN(num)) {
                    maxNum = Math.max(maxNum, num);
                }
            }
        });
        return maxNum + 1;
    }

    // --- Data Persistence Functions (Save/Load) --- (unchanged)
    function saveData() {
        inputFieldsData.forEach(field => {
            const group = inputFieldsContainer.querySelector(`.input-group[data-field-id="${field.id}"]`);
            if (!group) return;
            const textarea = group.querySelector(`textarea#input-${field.id}`);
            if (textarea) field.value = textarea.value;
            const label = group.querySelector(`label#label-${field.id}`);
            if (label && document.activeElement !== label && label.textContent !== field.label) {
                field.label = label.textContent.trim() || `æœªå‘½å ${field.id}:`;
            }
             const checkbox = group.querySelector(`input#include-${field.id}`);
             if (checkbox) field.includeInOutput = checkbox.checked;
        });
        const dataToSave = { fields: inputFieldsData, nextId: nextId, rate: speakingRate };
        try {
            localStorage.setItem(localStorageDataKey, JSON.stringify(dataToSave));
        } catch (e) {
            console.error("Error saving data to localStorage:", e);
            alert("æ— æ³•ä¿å­˜æ•°æ®ï¼Œå¯èƒ½æ˜¯æœ¬åœ°å­˜å‚¨å·²æ»¡æˆ–è¢«ç¦ç”¨ã€‚");
        }
    }
    function loadData() {
        const savedData = localStorage.getItem(localStorageDataKey);
        let loadedRate = DEFAULT_SPEAKING_RATE;
        const defaultFields = [
            { id: 1, label: "å¼•è¨€:", value: "", includeInOutput: true },
            { id: 2, label: "æ ¸å¿ƒè§‚ç‚¹ 1:", value: "", includeInOutput: true },
            { id: 3, label: "æ ¸å¿ƒè§‚ç‚¹ 2:", value: "", includeInOutput: true },
            { id: 4, label: "æ”¯æ’‘ç»†èŠ‚:", value: "", includeInOutput: true },
            { id: 5, label: "ç»“è®º:", value: "", includeInOutput: true }
        ];
        if (savedData) {
            try {
                const parsedData = JSON.parse(savedData);
                if (parsedData && Array.isArray(parsedData.fields)) {
                     inputFieldsData = parsedData.fields.map((f, index) => ({
                        id: parseInt(f.id, 10) || (Date.now() + index),
                        label: String(f.label || `æœªå‘½å ${f.id || index}:`).trim() || `æœªå‘½å ${f.id || index}:`,
                        value: String(f.value || ""),
                        includeInOutput: typeof f.includeInOutput === 'boolean' ? f.includeInOutput : true
                    }));
                    nextId = parsedData.nextId && typeof parsedData.nextId === 'number' ? parsedData.nextId : 1;
                    if (inputFieldsData.length > 0) {
                        const maxId = Math.max(0, ...inputFieldsData.map(f => f.id));
                        nextId = Math.max(nextId, maxId + 1);
                    } else { nextId = 1; }
                } else {
                     inputFieldsData = defaultFields;
                     nextId = defaultFields.length > 0 ? Math.max(0, ...defaultFields.map(f => f.id)) + 1 : 1;
                }
                if (parsedData && typeof parsedData.rate === 'number' && parsedData.rate >= MIN_SPEAKING_RATE && parsedData.rate <= MAX_SPEAKING_RATE) {
                    loadedRate = parsedData.rate;
                }
            } catch (e) {
                console.error("Error parsing saved data:", e);
                localStorage.removeItem(localStorageDataKey);
                inputFieldsData = defaultFields;
                nextId = defaultFields.length > 0 ? Math.max(0, ...defaultFields.map(f => f.id)) + 1 : 1;
            }
        } else {
            inputFieldsData = defaultFields;
            nextId = defaultFields.length > 0 ? Math.max(0, ...defaultFields.map(f => f.id)) + 1 : 1;
        }
        speakingRate = loadedRate;
        statsRateValueEl.textContent = speakingRate;
        if (!savedData) { saveData(); }
    }

    // --- UI Rendering Function --- (unchanged)
    function renderInputFields() {
        inputFieldsContainer.innerHTML = '';
        if (inputFieldsData.length === 0) {
            inputFieldsContainer.innerHTML = `<p class="empty-message">ç‚¹å‡»ä¸‹æ–¹çš„ "${addFieldBtn.textContent}" æŒ‰é’®æ¥åˆ›å»ºç¬¬ä¸€ä¸ªè¾“å…¥æ¡†ï¼Œæˆ–ä½¿ç”¨ "å¯¼å…¥ TXT" æŒ‰é’®åŠ è½½æ•°æ®ã€‚</p>`;
            downloadTxtBtn.disabled = true;
        } else {
            downloadTxtBtn.disabled = false;
            inputFieldsData.forEach((fieldData, index) => {
                const inputGroup = document.createElement('div');
                inputGroup.classList.add('input-group');
                inputGroup.dataset.fieldId = fieldData.id;
                inputGroup.dataset.index = index;
                inputGroup.draggable = true;
                const header = document.createElement('div');
                header.classList.add('input-group-header');
                const label = document.createElement('label');
                label.setAttribute('for', `input-${fieldData.id}`);
                label.classList.add('editable-label');
                label.setAttribute('contenteditable', 'false');
                label.dataset.labelId = fieldData.id;
                label.textContent = fieldData.label;
                label.setAttribute('id', `label-${fieldData.id}`);
                label.title = "å•å‡»æˆ–åŒå‡»ç¼–è¾‘æ ‡ç­¾";
                let clickTimeout = null; const clickDelay = 250;
                label.addEventListener('mousedown', (event) => { if (label.isContentEditable) {} });
                label.addEventListener('click', (event) => { if (event.detail === 1 && !label.isContentEditable && document.activeElement !== label) { clearTimeout(clickTimeout); clickTimeout = setTimeout(() => { if (document.body.contains(label)) { label.setAttribute('contenteditable', 'true'); label.focus(); requestAnimationFrame(() => { try { window.getSelection()?.selectAllChildren(label); } catch (e) {} }); } }, clickDelay); } });
                label.addEventListener('dblclick', (event) => { if (event.target === label) { clearTimeout(clickTimeout); label.setAttribute('contenteditable', 'true'); label.focus(); requestAnimationFrame(() => { try { window.getSelection()?.selectAllChildren(label); } catch (e) {} }); } });
                label.addEventListener('blur', (e) => { handleLabelBlur(e); e.target.setAttribute('contenteditable', 'false'); });
                label.addEventListener('keydown', handleLabelKeydown);
                const buttonContainer = document.createElement('div'); buttonContainer.classList.add('input-group-buttons');
                const insertBtn = document.createElement('button'); insertBtn.classList.add('action-icon-btn', 'insert-btn'); insertBtn.setAttribute('aria-label', `åœ¨æ­¤ä¸‹æ–¹æ’å…¥æ–°æ¡ç›® (${fieldData.label})`); insertBtn.title = 'åœ¨æ­¤ä¸‹æ–¹æ’å…¥æ–°æ¡ç›®'; insertBtn.textContent = '+'; insertBtn.dataset.fieldId = fieldData.id; insertBtn.addEventListener('click', handleInsertFieldBelow);
                const checkboxLabel = document.createElement('label'); checkboxLabel.classList.add('include-checkbox-label'); checkboxLabel.title = 'å‹¾é€‰æ­¤é¡¹ä»¥åŒ…å«åœ¨è¾“å‡ºå’Œå¤åˆ¶å†…å®¹ä¸­';
                const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.checked = fieldData.includeInOutput; checkbox.dataset.fieldId = fieldData.id; checkbox.id = `include-${fieldData.id}`; checkbox.addEventListener('change', handleIncludeCheckboxChange); checkboxLabel.appendChild(checkbox);
                const deleteBtn = document.createElement('button'); deleteBtn.classList.add('action-icon-btn', 'delete-btn'); deleteBtn.setAttribute('aria-label', `åˆ é™¤æ¡ç›® ${fieldData.label}`); deleteBtn.title = 'åˆ é™¤æ­¤é¡¹'; deleteBtn.textContent = 'âˆ’'; deleteBtn.dataset.fieldId = fieldData.id; deleteBtn.addEventListener('click', handleDeleteField);
                buttonContainer.appendChild(insertBtn); buttonContainer.appendChild(checkboxLabel); buttonContainer.appendChild(deleteBtn);
                header.appendChild(label); header.appendChild(buttonContainer);
                const textarea = document.createElement('textarea'); textarea.setAttribute('id', `input-${fieldData.id}`); textarea.setAttribute('aria-describedby', `label-${fieldData.id}`); textarea.classList.add('input-box'); textarea.setAttribute('rows', '3'); textarea.setAttribute('placeholder', `å…³äº "${fieldData.label.replace(':', '')}" çš„å†…å®¹...`); textarea.value = fieldData.value || ""; textarea.addEventListener('input', handleTextareaInput);
                inputGroup.appendChild(header); inputGroup.appendChild(textarea);
                inputFieldsContainer.appendChild(inputGroup);
            });
        }
        updateArticle();
    }

    // --- Event Handlers (Label, Delete, Insert, Add, Textarea Input) --- (unchanged)
    function handleLabelBlur(event) { const label = event.target; const fieldId = parseInt(label.dataset.labelId, 10); let newText = label.textContent.trim(); const field = inputFieldsData.find(f => f.id === fieldId); if (field) { const originalLabel = field.label; if (!newText) { newText = `æœªå‘½å ${fieldId}:`; label.textContent = newText; } if (newText !== originalLabel) { field.label = newText; const group = label.closest('.input-group'); const textarea = group?.querySelector(`#input-${fieldId}`); const insertBtn = group?.querySelector('.insert-btn'); const deleteBtn = group?.querySelector('.delete-btn'); if (textarea) textarea.placeholder = `å…³äº "${newText.replace(':', '')}" çš„å†…å®¹...`; if (insertBtn) insertBtn.setAttribute('aria-label', `åœ¨æ­¤ä¸‹æ–¹æ’å…¥æ–°æ¡ç›® (${newText})`); if (deleteBtn) deleteBtn.setAttribute('aria-label', `åˆ é™¤æ¡ç›® ${newText}`); debounceSaveData(); updateArticle(); } } label.setAttribute('contenteditable', 'false'); }
    function handleLabelKeydown(event) { if (event.target.isContentEditable) { if (event.key === 'Enter') { event.preventDefault(); event.target.blur(); } else if (event.key === 'Escape') { const field = inputFieldsData.find(f => f.id === parseInt(event.target.dataset.labelId, 10)); if (field) event.target.textContent = field.label; event.target.blur(); } } }
    function handleDeleteField(event) { const button = event.target.closest('button.delete-btn'); if (!button) return; const fieldIdToDelete = parseInt(button.dataset.fieldId, 10); const field = inputFieldsData.find(f => f.id === fieldIdToDelete); const labelToDelete = field ? field.label : `æ¡ç›® ${fieldIdToDelete}`; if (confirm(`ç¡®å®šè¦åˆ é™¤ "${labelToDelete}" åŠå…¶å†…å®¹å—ï¼Ÿ`)) { inputFieldsData = inputFieldsData.filter(f => f.id !== fieldIdToDelete); saveData(); renderInputFields(); } }
    function handleInsertFieldBelow(event) { const button = event.target.closest('button.insert-btn'); if (!button) return; const fieldIdToInsertBelow = parseInt(button.dataset.fieldId, 10); const index = inputFieldsData.findIndex(f => f.id === fieldIdToInsertBelow); if (index === -1) return; const newFieldId = nextId++; const nextItemNumber = getNextDefaultItemNumber(inputFieldsData); const newField = { id: newFieldId, label: `${defaultItemLabelPrefix}${nextItemNumber}:`, value: "", includeInOutput: true }; inputFieldsData.splice(index + 1, 0, newField); saveData(); renderInputFields(); focusAndScrollToField(newFieldId); }
    function handleAddField() { const newFieldId = nextId++; const nextItemNumber = getNextDefaultItemNumber(inputFieldsData); const newField = { id: newFieldId, label: `${defaultItemLabelPrefix}${nextItemNumber}:`, value: "", includeInOutput: true }; inputFieldsData.push(newField); saveData(); renderInputFields(); focusAndScrollToField(newFieldId); }
    function focusAndScrollToField(fieldId) { requestAnimationFrame(() => { const newGroup = inputFieldsContainer.querySelector(`.input-group[data-field-id="${fieldId}"]`); if (newGroup) { newGroup.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); const newLabel = newGroup.querySelector('label.editable-label'); if (newLabel) { setTimeout(() => { newLabel.setAttribute('contenteditable', 'true'); newLabel.focus(); try { window.getSelection()?.selectAllChildren(newLabel); } catch (e) {} }, 150); } } }); }
    function handleTextareaInput(event) { const textarea = event.target; const fieldId = parseInt(textarea.id.replace('input-', ''), 10); const field = inputFieldsData.find(f => f.id === fieldId); if (field) { field.value = textarea.value; debounceSaveData(); } updateArticle(); }
    function debounceSaveData(delay = 600) { clearTimeout(saveTimeout); saveTimeout = setTimeout(() => { saveData(); }, delay); }
    function handleIncludeCheckboxChange(event) { const checkbox = event.target; const fieldId = parseInt(checkbox.dataset.fieldId, 10); const field = inputFieldsData.find(f => f.id === fieldId); if (field) { field.includeInOutput = checkbox.checked; debounceSaveData(); updateArticle(); } }

    // --- Character Counting and Time Estimation Function --- (unchanged)
    function updateCharacterCounts(text) { let hanziCount = 0, biaodianCount = 0, zimuCount = 0, shuziCount = 0; for (let i = 0; i < text.length; i++) { const char = text[i]; const code = char.charCodeAt(0); if (char.match(/[\u4e00-\u9fa5]/)) { hanziCount++; } else if (code >= 0xFF01 && code <= 0xFF60) { biaodianCount++; } else if (code >= 0x3000 && code <= 0x303F) { biaodianCount++; } else if (char.match(/[0-9]/)) { shuziCount++; } else if (char.match(/[a-zA-Z]/)) { zimuCount++; } else if (code >= 33 && code <= 126) { zimuCount++; } } const totalChars = hanziCount + biaodianCount + zimuCount + shuziCount; statsTotalEl.textContent = totalChars; statsHanziEl.textContent = hanziCount; statsBiaodianEl.textContent = biaodianCount; statsZimuEl.textContent = zimuCount; statsShuziEl.textContent = shuziCount; let minutes = 0, seconds = 0; if (hanziCount > 0 && speakingRate > 0) { const totalSeconds = Math.round((hanziCount / speakingRate) * 60); minutes = Math.floor(totalSeconds / 60); seconds = totalSeconds % 60; } statsTimeEl.textContent = `${minutes}åˆ†${seconds}ç§’`; }

    // --- Core Article Update Function --- (unchanged)
    function updateArticle() { inputFieldsData.forEach(field => { const group = inputFieldsContainer.querySelector(`.input-group[data-field-id="${field.id}"]`); if (!group) return; const labelElement = group.querySelector(`label#label-${field.id}`); if (labelElement && document.activeElement !== labelElement) { const currentLabelText = labelElement.textContent.trim(); if (currentLabelText && currentLabelText !== field.label) field.label = currentLabelText; } const textareaElement = group.querySelector(`textarea#input-${field.id}`); if(textareaElement && field.value !== textareaElement.value) field.value = textareaElement.value; const checkboxElement = group.querySelector(`input#include-${field.id}`); if (checkboxElement && field.includeInOutput !== checkboxElement.checked) field.includeInOutput = checkboxElement.checked; }); const fieldsToDisplay = inputFieldsData.filter(field => field.includeInOutput && field.value.trim() !== ''); if (fieldsToDisplay.length === 0) { outputArea.innerHTML = '<div class="empty-message">æ²¡æœ‰å‹¾é€‰ä¸”åŒ…å«å†…å®¹çš„æ¡ç›®å¯æ˜¾ç¤º...</div>'; } else { const displayContentHTML = fieldsToDisplay.map(field => { const safeLabel = escapeHTML(field.label.replace(/:$/, '')); const safeValue = escapeHTML(field.value); return `<div><strong>${safeLabel}:</strong> ${safeValue}</div>`; }).join(''); outputArea.innerHTML = displayContentHTML; } const fieldsToCountAndCopy = inputFieldsData.filter(field => field.includeInOutput && field.value.trim() !== ''); const contentForCountingAndCopy = fieldsToCountAndCopy.map(field => field.value.trim()).join('\n'); updateCharacterCounts(contentForCountingAndCopy); if (contentForCountingAndCopy.length > 0) { if (!copyBtn.classList.contains('copied')) copyBtn.textContent = 'å¤åˆ¶æ–‡ç« '; copyBtn.disabled = false; } else { copyBtn.disabled = true; copyBtn.textContent = 'å¤åˆ¶æ–‡ç« '; copyBtn.classList.remove('copied'); } downloadTxtBtn.disabled = inputFieldsData.length === 0; }


    // --- Copy Button Logic --- MODIFIED to use fallback ---
    copyBtn.addEventListener('click', () => {
        if (copyBtn.disabled || copyBtn.classList.contains('copied')) return;

        const textToCopy = inputFieldsData
            .filter(field => field.includeInOutput && field.value.trim() !== '')
            .map(field => field.value.trim()).join('\n');

        if (!textToCopy) return;

        // --- Fallback Copy Method using document.execCommand ---
        // Create a temporary textarea element
        const fallbackTextArea = document.createElement('textarea');
        fallbackTextArea.value = textToCopy;
        // Make it non-editable and visually hidden but still part of the DOM
        fallbackTextArea.setAttribute('readonly', '');
        // Use a class for styling the hidden textarea
        fallbackTextArea.classList.add('copy-fallback-textarea');

        document.body.appendChild(fallbackTextArea);

        // Select the text inside the textarea
        fallbackTextArea.select();
        // For mobile devices
        fallbackTextArea.setSelectionRange(0, 99999);

        let success = false;
        try {
            // Execute the copy command
            success = document.execCommand('copy');
            console.log('Fallback copy command success:', success);
        } catch (err) {
            console.error('Fallback copy command failed:', err);
            success = false;
        }

        // Remove the temporary textarea
        document.body.removeChild(fallbackTextArea);

        // Provide feedback to the user
        if (success) {
            copyBtn.textContent = 'å·²å¤åˆ¶!'; copyBtn.classList.add('copied'); copyBtn.disabled = true;
            setTimeout(() => {
                copyBtn.textContent = 'å¤åˆ¶æ–‡ç« '; copyBtn.classList.remove('copied');
                const stillHasContentToCopy = inputFieldsData.some(field => field.includeInOutput && field.value.trim() !== '');
                copyBtn.disabled = !stillHasContentToCopy;
            }, 2000);
        } else {
            // If even the fallback fails, notify the user.
            console.error('æ— æ³•ä½¿ç”¨ document.execCommand å¤åˆ¶æ–‡æœ¬ã€‚');
            alert('è‡ªåŠ¨å¤åˆ¶å¤±è´¥ã€‚è¯·æ‰‹åŠ¨é€‰ä¸­é¢„è§ˆåŒºå†…å®¹è¿›è¡Œå¤åˆ¶ã€‚');
            // Optional: Keep the button enabled to allow manual copying
            // copyBtn.disabled = false;
        }
        // --- End of Fallback Copy Method ---

        /* --- Original navigator.clipboard (commented out for fallback) ---
        navigator.clipboard.writeText(textToCopy).then(() => {
            copyBtn.textContent = 'å·²å¤åˆ¶!'; copyBtn.classList.add('copied'); copyBtn.disabled = true;
            setTimeout(() => {
                copyBtn.textContent = 'å¤åˆ¶æ–‡ç« '; copyBtn.classList.remove('copied');
                const stillHasContentToCopy = inputFieldsData.some(field => field.includeInOutput && field.value.trim() !== '');
                copyBtn.disabled = !stillHasContentToCopy;
            }, 2000);
        }).catch(err => {
             console.error('æ— æ³•ä½¿ç”¨ navigator.clipboard å¤åˆ¶æ–‡æœ¬: ', err);
             alert('å¤åˆ¶å¤±è´¥ã€‚æ‚¨çš„æµè§ˆå™¨å¯èƒ½ä¸æ”¯æŒæˆ–åœ¨éå®‰å…¨ç¯å¢ƒä¸‹è¿è¡Œã€‚è¯·å°è¯•æ‰‹åŠ¨å¤åˆ¶ã€‚');
        });
        */
    });

    // --- Download TXT Button Logic --- (unchanged)
    function handleDownloadTxt() { if (downloadTxtBtn.disabled || inputFieldsData.length === 0) return; saveData(); const textContent = inputFieldsData.map(field => { const labelPrefix = field.includeInOutput ? "" : UNCHECKED_ITEM_PREFIX; const labelText = field.label.trim().replace(/:$/, '') + ':'; return `${labelPrefix}${labelText} ${field.value}`; }).join('\n\n'); const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; const dateStr = new Date().toISOString().slice(0, 10); link.download = `article_data_${dateStr}.txt`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); }

    // --- Import TXT Logic --- (unchanged)
    function handleImportTxtClick() { importFileInput.value = null; importFileInput.click(); }
    function handleFileSelected(event) { const file = event.target.files[0]; if (!file) return; if (file.type !== 'text/plain') { alert('è¯·é€‰æ‹©ä¸€ä¸ªæœ‰æ•ˆçš„ .txt æ–‡ä»¶ã€‚'); return; } if (!confirm('è¿™å°†è¦†ç›–å½“å‰æ‰€æœ‰æ•°æ®ï¼Œç¡®å®šè¦å¯¼å…¥å—ï¼Ÿ')) return; const reader = new FileReader(); reader.onload = (e) => { const textContent = e.target.result; try { const parsedData = parseImportedTxt(textContent); if (parsedData === null) { alert('æ— æ³•è§£ææ–‡ä»¶å†…å®¹ã€‚è¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼ä¸º "æ ‡ç­¾: å†…å®¹" æˆ– "[ ] æ ‡ç­¾: å†…å®¹"ï¼Œæ¡ç›®é—´ç”¨åŒæ¢è¡Œåˆ†éš”ã€‚'); return; } inputFieldsData = parsedData; if (inputFieldsData.length > 0) { const maxImportedId = Math.max(0, ...inputFieldsData.map(f => f.id)); nextId = maxImportedId + 1; } else { nextId = 1; } saveData(); renderInputFields(); alert('æ•°æ®å¯¼å…¥æˆåŠŸï¼'); } catch (parseError) { console.error("Error parsing imported file:", parseError); alert(`å¯¼å…¥æ–‡ä»¶æ—¶å‡ºé”™ï¼š${parseError.message}`); } }; reader.onerror = (e) => { console.error("Error reading file:", e); alert('è¯»å–æ–‡ä»¶æ—¶å‡ºé”™ã€‚'); }; reader.readAsText(file); }
    function parseImportedTxt(textContent) { if (typeof textContent !== 'string' || textContent.trim() === '') { return []; } const blocks = textContent.trim().split('\n\n'); const parsedFields = []; let currentId = 1; for (const block of blocks) { const trimmedBlock = block.trim(); if (!trimmedBlock) continue; const colonIndex = trimmedBlock.indexOf(':'); if (colonIndex > 0) { let rawLabelWithValuePrefix = trimmedBlock.substring(0, colonIndex).trim(); const value = trimmedBlock.substring(colonIndex + 1).trim(); let includeInOutput = true; let finalLabel = rawLabelWithValuePrefix; if (rawLabelWithValuePrefix.startsWith(UNCHECKED_ITEM_PREFIX)) { includeInOutput = false; finalLabel = rawLabelWithValuePrefix.substring(UNCHECKED_ITEM_PREFIX.length).trim(); } if (!finalLabel) { finalLabel = `æœªå‘½å ${currentId}`; } if (!finalLabel.endsWith(':')) { finalLabel += ':'; } parsedFields.push({ id: currentId++, label: finalLabel, value: value, includeInOutput: includeInOutput }); } else { console.warn("Skipping invalid block during import (missing ':' or format error):", trimmedBlock); } } if (parsedFields.length === 0 && textContent.trim().length > 0) { console.warn("Import text was not empty, but no valid fields were parsed."); return null; } return parsedFields; }

    // --- Event Handlers for Editable Rate Span --- (unchanged)
    function handleRateDblClick(event) { const target = event.target; target.contentEditable = 'true'; target.focus(); requestAnimationFrame(() => { try { window.getSelection()?.selectAllChildren(target); } catch (e) {} }); }
    function handleRateBlur(event) { const target = event.target; const newRateText = target.textContent.trim(); let newRate = parseInt(newRateText, 10); let isValid = false; if (!isNaN(newRate)) { newRate = Math.max(MIN_SPEAKING_RATE, Math.min(MAX_SPEAKING_RATE, newRate)); isValid = true; } target.contentEditable = 'false'; if (isValid) { if (newRate !== speakingRate) { speakingRate = newRate; target.textContent = speakingRate; debounceSaveData(); updateArticle(); } else { target.textContent = speakingRate; } } else { target.textContent = speakingRate; } }
    function handleRateKeydown(event) { if (event.target.isContentEditable) { if (event.key === 'Enter') { event.preventDefault(); event.target.blur(); } else if (event.key === 'Escape') { event.target.textContent = speakingRate; event.target.blur(); } } }

    // --- Drag and Drop Event Handlers --- (unchanged)
    function handleDragStart(e) { const targetGroup = e.target.closest('.input-group'); const actualTarget = e.target; if (!targetGroup) return; if (actualTarget.tagName === 'TEXTAREA' || actualTarget.tagName === 'INPUT' || actualTarget.tagName === 'BUTTON' || actualTarget.closest('.input-group-buttons') || (actualTarget.classList.contains('editable-label') && actualTarget.isContentEditable) || window.getSelection()?.toString().length > 0) { e.preventDefault(); return; } draggedItemId = parseInt(targetGroup.dataset.fieldId, 10); if (isNaN(draggedItemId)) return; e.dataTransfer.setData('text/plain', draggedItemId.toString()); e.dataTransfer.effectAllowed = 'move'; setTimeout(() => { const element = inputFieldsContainer.querySelector(`.input-group[data-field-id="${draggedItemId}"]`); if(element) element.classList.add('dragging'); }, 0); }
    function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; const targetGroup = e.target.closest('.input-group'); clearDragOverIndicators(); if (!targetGroup || !draggedItemId || parseInt(targetGroup.dataset.fieldId, 10) === draggedItemId) return; targetGroup.classList.add('drag-over-indicator'); }
    function handleDragLeave(e) { if (!e.currentTarget.contains(e.relatedTarget)) { clearDragOverIndicators(); } else { const targetGroup = e.target.closest('.input-group'); if (targetGroup && !targetGroup.contains(e.relatedTarget)) { targetGroup.classList.remove('drag-over-indicator'); targetGroup.style.marginTop = ''; targetGroup.style.marginBottom = ''; } } }
    function handleDrop(e) { e.preventDefault(); clearDragOverIndicators(); const targetGroup = e.target.closest('.input-group'); const droppedItemIdStr = e.dataTransfer.getData('text/plain'); if (!droppedItemIdStr || !targetGroup) { handleDragEndCleanup(null); return; } const draggedId = parseInt(droppedItemIdStr, 10); const targetId = parseInt(targetGroup.dataset.fieldId, 10); if (isNaN(draggedId) || isNaN(targetId) || draggedId === targetId) { handleDragEndCleanup(draggedId); return; } const draggedIndex = inputFieldsData.findIndex(field => field.id === draggedId); if (draggedIndex === -1) { console.error("Drag Error: Dragged item not found."); handleDragEndCleanup(draggedId); return; } const [draggedItem] = inputFieldsData.splice(draggedIndex, 1); const newTargetIndex = inputFieldsData.findIndex(field => field.id === targetId); if (newTargetIndex !== -1) { inputFieldsData.splice(newTargetIndex, 0, draggedItem); } else { inputFieldsData.push(draggedItem); console.warn("Drop target index issue, appended item."); } saveData(); renderInputFields(); }
    function handleDragEnd(e) { handleDragEndCleanup(draggedItemId); }
    function handleDragEndCleanup(itemId) { clearDragOverIndicators(); const draggedElement = inputFieldsContainer.querySelector(`.input-group.dragging`); if (draggedElement) draggedElement.classList.remove('dragging'); draggedItemId = null; }
    function clearDragOverIndicators() { inputFieldsContainer.querySelectorAll('.drag-over-indicator').forEach(el => { el.classList.remove('drag-over-indicator'); el.style.marginTop = ''; el.style.marginBottom = ''; }); }

    // --- Initialization --- (unchanged)
    document.addEventListener('DOMContentLoaded', () => {
        addFieldBtn.addEventListener('click', handleAddField);
        downloadTxtBtn.addEventListener('click', handleDownloadTxt);
        importTxtBtn.addEventListener('click', handleImportTxtClick);
        importFileInput.addEventListener('change', handleFileSelected);
        loadData();
        renderInputFields();
        statsRateValueEl.addEventListener('dblclick', handleRateDblClick);
        statsRateValueEl.addEventListener('blur', handleRateBlur);
        statsRateValueEl.addEventListener('keydown', handleRateKeydown);
        inputFieldsContainer.addEventListener('dragstart', handleDragStart);
        inputFieldsContainer.addEventListener('dragover', handleDragOver);
        inputFieldsContainer.addEventListener('dragleave', handleDragLeave);
        inputFieldsContainer.addEventListener('drop', handleDrop);
        inputFieldsContainer.addEventListener('dragend', handleDragEnd);
    });
</script>

</body></html>