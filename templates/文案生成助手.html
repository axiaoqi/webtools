<!DOCTYPE html>
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ¨æ€æ–‡ç« ç”Ÿæˆå·¥å…· (å­—æ•°ç»Ÿè®¡/å‹¾é€‰è¾“å‡º/åŒå‡»æ”¹é€Ÿç‡/å¤åˆ¶çº¯æ–‡æœ¬/ä¸‹è½½TXT)</title>
    <style>
        /* --- Styles mostly unchanged --- */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; padding: 20px; background-color: #f8f9fa; color: #212529; }
        .container { max-width: 750px; margin: 20px auto; background: #fff; padding: 25px 35px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); border: 1px solid #dee2e6; }
        h1 { color: #343a40; text-align: center; margin-bottom: 15px; font-weight: 600; }
        .description { text-align: center; color: #6c757d; margin-bottom: 30px; font-size: 0.95em; }
        .input-fields { margin-bottom: 25px; padding-bottom: 10px; }
        .input-group { margin-bottom: 18px; padding: 15px; border: 1px solid #e9ecef; border-radius: 6px; background-color: #fff; position: relative; display: flex; flex-direction: column; transition: box-shadow 0.2s ease-in-out; }
        .input-group:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
        .input-group-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; gap: 10px; }
        label.editable-label { font-weight: 600; color: #495057; font-size: 0.95em; cursor: text; padding: 3px 6px; border-radius: 4px; transition: background-color 0.2s ease, box-shadow 0.2s ease; flex-grow: 1; word-break: break-word; line-height: 1.4; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; min-width: 50px; }
        label.editable-label:hover { background-color: #f1f3f5; }
        label.editable-label:focus { background-color: #e7f5ff; outline: none; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2); }
        textarea.input-box { padding: 12px; border: 1px solid #ced4da; border-radius: 4px; font-size: 1em; min-height: 55px; resize: vertical; box-sizing: border-box; width: 100%; transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; }
        textarea.input-box:focus { border-color: #86b7fe; outline: 0; box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25); }
        .input-group-buttons { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }
        .include-checkbox-label { display: flex; align-items: center; cursor: pointer; margin-right: 4px; padding: 2px; border-radius: 3px; }
        .include-checkbox-label input[type="checkbox"] { margin: 0; width: 16px; height: 16px; cursor: pointer; accent-color: #0d6efd; vertical-align: middle; }
        .include-checkbox-label:hover { background-color: #f1f3f5; }
        button.action-icon-btn { color: white; border: none; border-radius: 50%; width: 26px; height: 26px; font-size: 18px; font-weight: bold; line-height: 26px; text-align: center; cursor: pointer; padding: 0; transition: background-color 0.2s ease, transform 0.1s ease; display: flex; align-items: center; justify-content: center; }
        button.action-icon-btn:hover { transform: scale(1.1); }
        button.action-icon-btn:active { transform: scale(1); }
        button.insert-btn { background-color: #198754; }
        button.insert-btn:hover { background-color: #157347; }
        button.delete-btn { background-color: #e63946; }
        button.delete-btn:hover { background-color: #d62828; }
        #add-field-btn { display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%; padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; font-weight: 500; margin-top: 20px; transition: background-color 0.3s ease; }
        #add-field-btn::before { content: '+'; font-size: 1.2em; line-height: 1; }
        #add-field-btn:hover { background-color: #0056b3; }
        .action-button-group { display: flex; justify-content: center; gap: 15px; margin-top: 25px; margin-bottom: 30px; }

        .action-button-group button {
            padding: 12px 25px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.05em;
            font-weight: 500;
            transition: background-color 0.3s ease, opacity 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .action-button-group button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.65;
        }

        #copy-btn { background-color: #28a745; }
        #copy-btn::before { content: 'ğŸ“‹'; font-size: 1.1em; }
        #copy-btn:hover:not(:disabled) { background-color: #218838; }
        #copy-btn.copied { background-color: #198754; }
        #copy-btn.copied::before { content: 'âœ…'; }

        #download-txt-btn { background-color: #fd7e14; }
        #download-txt-btn::before { content: 'ğŸ’¾'; font-size: 1.1em; }
        #download-txt-btn:hover:not(:disabled) { background-color: #e66800; }

        .output-section { margin-top: 20px; }
        #output-label { font-weight: 600; color: #343a40; display: block; margin-bottom: 8px; font-size: 1.1em; }
        #output-stats { font-size: 0.88em; color: #6c757d; margin-bottom: 10px; line-height: 1.8; padding-left: 5px; }
        .stat-item { display: inline-block; margin-right: 15px; white-space: nowrap; margin-bottom: 5px; }
        .stat-item:last-child { margin-right: 0; }
        .stat-value { font-weight: bold; color: #495057; }
        .stat-item-hanzi .stat-value { color: #dc3545; }
        .stat-item-punct .stat-value { color: #0dcaf0; }
        .stat-item-letter .stat-value { color: #198754; }
        .stat-item-digit .stat-value { color: #ffc107; }
        .stat-item-time .stat-value { color: #6f42c1; }
        #stats-rate-value { display: inline-block; font-weight: bold; color: #6f42c1; cursor: text; padding: 1px 4px; border-radius: 3px; transition: background-color 0.2s ease, box-shadow 0.2s ease; min-width: 25px; text-align: center; }
        #stats-rate-value:hover { background-color: #f1f3f5; }
        #stats-rate-value:focus { background-color: #e7f5ff; outline: none; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2); }
        .output-area-div { width: 100%; min-height: 200px; padding: 15px; border: 1px solid #ced4da; background-color: #f8f9fa; border-radius: 6px; font-size: 1em; line-height: 1.7; box-sizing: border-box; white-space: pre-wrap; overflow-wrap: break-word; transition: background-color 0.3s ease, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; color: #495057; display: block; margin-top: 0; overflow-y: auto; }
        .output-area-div:focus { border-color: #86b7fe; outline: 0; box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25); background-color: #fff; }
        .output-area-div strong { font-weight: 700; color: #343a40; margin-right: 0.3em; /* Slightly reduced margin */ }
        .output-area-div .empty-message { text-align: center; color: #6c757d; padding: 20px 0; font-style: italic; width: 100%; font-weight: normal; }
        .output-area-div > div:not(.empty-message) { margin-bottom: 0.2em; }
        .output-area-div > div:last-child { margin-bottom: 0; }
        .empty-message {
            text-align: center; color: #6c757d; padding: 20px 0; font-style: italic;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>åŠ¨æ€æ–‡ç« ç”Ÿæˆå·¥å…·</h1>
    <p class="description">è¾“å…¥å†…å®¹å®æ—¶ç”Ÿæˆå¸¦æ ‡ç­¾é¢„è§ˆ (å¯<strong>å‹¾é€‰</strong>æ˜¯å¦è¾“å‡º)ã€‚å¯ä¿®æ”¹æ ‡ç­¾ã€æ’å…¥/åˆ é™¤æ¡ç›®ã€‚<strong>å¤åˆ¶æŒ‰é’®ä»…å¤åˆ¶å‹¾é€‰æ¡ç›®çš„çº¯æ–‡æœ¬ã€‚</strong> æ–°å¢ <strong>ä¸‹è½½ TXT</strong> æŒ‰é’®å¯ä¿å­˜æ‰€æœ‰æ ‡ç­¾å’Œå†…å®¹ã€‚å®æ—¶å­—æ•°ç»Ÿè®¡ã€å£æ’­æ—¶é•¿ä¼°ç®—ï¼ˆ<strong title="åŒå‡»ä¸‹æ–¹æ‹¬å·é‡Œçš„æ•°å­—å³å¯ä¿®æ”¹">é€Ÿç‡å¯è°ƒ</strong>ï¼‰æ˜¾ç¤ºåœ¨é¢„è§ˆåŒºä¸Šæ–¹ã€‚</p>

    <div id="input-fields" class="input-fields">
        <!-- Input fields will be generated here by JS -->
    </div>

    <button id="add-field-btn">æ·»åŠ æ–°æ¡ç›®åˆ°æœ«å°¾</button>

    <div class="action-button-group">
        <button id="copy-btn" disabled="">å¤åˆ¶æ–‡ç« </button>
        <button id="download-txt-btn" disabled="">ä¸‹è½½ TXT</button>
    </div>

    <div class="output-section">
        <label for="output-area" id="output-label">ç”Ÿæˆçš„æ–‡ç«  (å¸¦æ ‡ç­¾é¢„è§ˆ, ä»…æ˜¾ç¤ºå‹¾é€‰æ¡ç›®):</label>
        <div id="output-stats">
             <span class="stat-item stat-item-total">æ€»å­—æ•°(å‹¾é€‰): <span class="stat-value" id="stats-total">0</span></span>
             <span class="stat-item stat-item-hanzi">æ±‰å­—(å‹¾é€‰): <span class="stat-value" id="stats-hanzi">0</span></span>
             <span class="stat-item stat-item-punct">æ ‡ç‚¹(å…¨è§’): <span class="stat-value" id="stats-biaodian">0</span></span>
             <span class="stat-item stat-item-letter">å­—æ¯/ç¬¦(åŠè§’): <span class="stat-value" id="stats-zimu">0</span></span>
             <span class="stat-item stat-item-digit">æ•°å­—: <span class="stat-value" id="stats-shuzi">0</span></span>
             <br>
             <span class="stat-item stat-item-time">
                 å£æ’­æ—¶é•¿(<span id="stats-rate-value" contenteditable="false" title="åŒå‡»ä¿®æ”¹é€Ÿç‡ (50-1000)">300</span>å­—/åˆ†é’Ÿ):
                 <span class="stat-value" id="stats-time">0åˆ†0ç§’</span>
             </span>
        </div>
        <div id="output-area" class="output-area-div" role="textbox" aria-readonly="true" aria-labelledby="output-label">
             <!-- Content will be added by JS -->
        </div>
    </div>

</div>

<script>
    // DOM Elements
    const inputFieldsContainer = document.getElementById('input-fields');
    const addFieldBtn = document.getElementById('add-field-btn');
    const copyBtn = document.getElementById('copy-btn');
    const downloadTxtBtn = document.getElementById('download-txt-btn');
    const outputArea = document.getElementById('output-area');
    const statsTotalEl = document.getElementById('stats-total');
    const statsHanziEl = document.getElementById('stats-hanzi');
    const statsBiaodianEl = document.getElementById('stats-biaodian');
    const statsZimuEl = document.getElementById('stats-zimu');
    const statsShuziEl = document.getElementById('stats-shuzi');
    const statsRateValueEl = document.getElementById('stats-rate-value');
    const statsTimeEl = document.getElementById('stats-time');

    // Constants and State
    const localStorageDataKey = 'dynamicArticleGeneratorData_v5';
    const defaultItemLabelPrefix = "æ–°æ¡ç›® ";
    const DEFAULT_SPEAKING_RATE = 300;
    const MIN_SPEAKING_RATE = 50;
    const MAX_SPEAKING_RATE = 1000;
    let inputFieldsData = [];
    let nextId = 1;
    let speakingRate = DEFAULT_SPEAKING_RATE;

    // --- Helper Function: Escape HTML ---
    function escapeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    // --- Helper Functions (getNextDefaultItemNumber) ---
    function getNextDefaultItemNumber(currentFieldsData) {
        let maxNum = 0;
        const regex = new RegExp(`^${defaultItemLabelPrefix.trim()}\\s*(\\d+):?$`, 'i');
        currentFieldsData.forEach(field => {
            const match = field.label.match(regex);
            if (match && match[1]) {
                const num = parseInt(match[1], 10);
                if (!isNaN(num)) {
                    maxNum = Math.max(maxNum, num);
                }
            }
        });
        return maxNum + 1;
    }

    // --- Data Persistence Functions (Save/Load) ---
    function saveData() {
        // Update value and label from DOM elements before saving
        inputFieldsData.forEach(field => {
            const textarea = document.getElementById(`input-${field.id}`);
            if (textarea) field.value = textarea.value;
            const label = document.getElementById(`label-${field.id}`);
            if (label && label.textContent !== field.label) {
                field.label = label.textContent.trim() || `æœªå‘½å ${field.id}:`;
            }
        });
        const dataToSave = { fields: inputFieldsData, nextId: nextId, rate: speakingRate };
        try {
            localStorage.setItem(localStorageDataKey, JSON.stringify(dataToSave));
        } catch (e) {
            console.error("Error saving data to localStorage:", e);
            alert("æ— æ³•ä¿å­˜æ•°æ®ï¼Œå¯èƒ½æ˜¯æœ¬åœ°å­˜å‚¨å·²æ»¡æˆ–è¢«ç¦ç”¨ã€‚");
        }
    }

    function loadData() {
        const savedData = localStorage.getItem(localStorageDataKey);
        let loadedRate = DEFAULT_SPEAKING_RATE;
        const defaultFields = [
            { id: 1, label: "å¼•è¨€:", value: "", includeInOutput: true },
            { id: 2, label: "æ ¸å¿ƒè§‚ç‚¹ 1:", value: "", includeInOutput: true },
            { id: 3, label: "æ ¸å¿ƒè§‚ç‚¹ 2:", value: "", includeInOutput: true },
            { id: 4, label: "æ”¯æ’‘ç»†èŠ‚:", value: "", includeInOutput: true },
            { id: 5, label: "ç»“è®º:", value: "", includeInOutput: true }
        ];

        if (savedData) {
            try {
                const parsedData = JSON.parse(savedData);
                if (parsedData && Array.isArray(parsedData.fields)) {
                    inputFieldsData = parsedData.fields.map(f => ({
                        id: parseInt(f.id, 10),
                        label: String(f.label || `æœªå‘½å ${f.id}:`).trim() || `æœªå‘½å ${f.id}:`,
                        value: String(f.value || ""),
                        includeInOutput: typeof f.includeInOutput === 'boolean' ? f.includeInOutput : true
                    }));
                    nextId = parsedData.nextId && typeof parsedData.nextId === 'number' ? parsedData.nextId : 1;
                    if (inputFieldsData.length > 0) {
                        nextId = Math.max(nextId, Math.max(...inputFieldsData.map(f => f.id)) + 1);
                    } else {
                        nextId = 1;
                    }
                } else {
                     inputFieldsData = defaultFields;
                     nextId = defaultFields.length > 0 ? Math.max(...defaultFields.map(f => f.id)) + 1 : 1;
                }
                if (parsedData && typeof parsedData.rate === 'number' && parsedData.rate >= MIN_SPEAKING_RATE && parsedData.rate <= MAX_SPEAKING_RATE) {
                    loadedRate = parsedData.rate;
                }
            } catch (e) {
                console.error("Error parsing saved data:", e);
                localStorage.removeItem(localStorageDataKey);
                inputFieldsData = defaultFields;
                nextId = defaultFields.length > 0 ? Math.max(...defaultFields.map(f => f.id)) + 1 : 1;
            }
        } else {
            inputFieldsData = defaultFields;
            nextId = defaultFields.length > 0 ? Math.max(...defaultFields.map(f => f.id)) + 1 : 1;
        }
        speakingRate = loadedRate;
        statsRateValueEl.textContent = speakingRate;
        if (!savedData) {
             saveData();
        }
    }

    // --- UI Rendering Function ---
    function renderInputFields() {
        inputFieldsContainer.innerHTML = '';
        if (inputFieldsData.length === 0) {
            inputFieldsContainer.innerHTML = `<p class="empty-message">ç‚¹å‡»ä¸‹æ–¹çš„ "${addFieldBtn.textContent}" æŒ‰é’®æ¥åˆ›å»ºç¬¬ä¸€ä¸ªè¾“å…¥æ¡†ã€‚</p>`;
            downloadTxtBtn.disabled = true;
        } else {
            downloadTxtBtn.disabled = false;
            inputFieldsData.forEach(fieldData => {
                const inputGroup = document.createElement('div');
                inputGroup.classList.add('input-group');
                inputGroup.dataset.fieldId = fieldData.id;

                const header = document.createElement('div');
                header.classList.add('input-group-header');

                const label = document.createElement('label');
                label.setAttribute('for', `input-${fieldData.id}`);
                label.classList.add('editable-label');
                label.setAttribute('contenteditable', 'true');
                label.dataset.labelId = fieldData.id;
                label.textContent = fieldData.label;
                label.setAttribute('id', `label-${fieldData.id}`);
                let clickTimeout = null; const clickDelay = 250; label.addEventListener('mousedown', (event) => { if (event.target === label && document.activeElement !== label) event.preventDefault(); }); label.addEventListener('click', (event) => { if (event.detail === 1) { clearTimeout(clickTimeout); clickTimeout = setTimeout(() => { if (document.body.contains(label) && document.activeElement !== label) label.focus(); }, clickDelay); } }); label.addEventListener('dblclick', (event) => { if (event.target === label) { clearTimeout(clickTimeout); label.focus(); try { const selection = window.getSelection(); const range = document.createRange(); range.selectNodeContents(label); selection?.removeAllRanges(); selection?.addRange(range); } catch (e) { console.error("Error selecting text:", e); } } });
                label.addEventListener('blur', handleLabelBlur);
                label.addEventListener('keydown', handleLabelKeydown);

                const buttonContainer = document.createElement('div');
                buttonContainer.classList.add('input-group-buttons');

                const insertBtn = document.createElement('button');
                insertBtn.classList.add('action-icon-btn', 'insert-btn');
                insertBtn.setAttribute('aria-label', `åœ¨æ­¤ä¸‹æ–¹æ’å…¥æ–°æ¡ç›® (${fieldData.label})`);
                insertBtn.title = 'åœ¨æ­¤ä¸‹æ–¹æ’å…¥æ–°æ¡ç›®';
                insertBtn.textContent = '+';
                insertBtn.dataset.fieldId = fieldData.id;
                insertBtn.addEventListener('click', handleInsertFieldBelow);

                const checkboxLabel = document.createElement('label');
                checkboxLabel.classList.add('include-checkbox-label');
                checkboxLabel.title = 'å‹¾é€‰æ­¤é¡¹ä»¥åŒ…å«åœ¨è¾“å‡ºå’Œå¤åˆ¶å†…å®¹ä¸­';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = fieldData.includeInOutput;
                checkbox.dataset.fieldId = fieldData.id;
                checkbox.id = `include-${fieldData.id}`;
                checkbox.addEventListener('change', handleIncludeCheckboxChange);

                checkboxLabel.appendChild(checkbox);

                const deleteBtn = document.createElement('button');
                deleteBtn.classList.add('action-icon-btn', 'delete-btn');
                deleteBtn.setAttribute('aria-label', `åˆ é™¤æ¡ç›® ${fieldData.label}`);
                deleteBtn.title = 'åˆ é™¤æ­¤é¡¹';
                deleteBtn.textContent = 'âˆ’';
                deleteBtn.dataset.fieldId = fieldData.id;
                deleteBtn.addEventListener('click', handleDeleteField);

                buttonContainer.appendChild(insertBtn);
                buttonContainer.appendChild(checkboxLabel);
                buttonContainer.appendChild(deleteBtn);

                header.appendChild(label);
                header.appendChild(buttonContainer);

                const textarea = document.createElement('textarea');
                textarea.setAttribute('id', `input-${fieldData.id}`);
                textarea.setAttribute('aria-describedby', `label-${fieldData.id}`);
                textarea.classList.add('input-box');
                textarea.setAttribute('rows', '3');
                textarea.setAttribute('placeholder', `å…³äº "${fieldData.label.replace(':', '')}" çš„å†…å®¹...`);
                textarea.value = fieldData.value || "";
                textarea.addEventListener('input', handleTextareaInput);

                inputGroup.appendChild(header);
                inputGroup.appendChild(textarea);
                inputFieldsContainer.appendChild(inputGroup);
            });
        }
        updateArticle();
    }

    // --- Event Handlers (Label, Delete, Insert, Add, Textarea Input) ---
    function handleLabelBlur(event) {
        const label = event.target; const fieldId = parseInt(label.dataset.labelId, 10); let newText = label.textContent.trim(); const field = inputFieldsData.find(f => f.id === fieldId); if (field) { const originalLabel = field.label; if (!newText) { newText = `æœªå‘½å ${fieldId}:`; label.textContent = newText; } if (newText !== originalLabel) { field.label = newText; const textarea = document.getElementById(`input-${fieldId}`); const group = label.closest('.input-group'); const insertBtn = group?.querySelector('.insert-btn'); const deleteBtn = group?.querySelector('.delete-btn'); if (textarea) textarea.placeholder = `å…³äº "${newText.replace(':', '')}" çš„å†…å®¹...`; if (insertBtn) insertBtn.setAttribute('aria-label', `åœ¨æ­¤ä¸‹æ–¹æ’å…¥æ–°æ¡ç›® (${newText})`); if (deleteBtn) deleteBtn.setAttribute('aria-label', `åˆ é™¤æ¡ç›® ${newText}`); saveData(); updateArticle(); } }
    }
    function handleLabelKeydown(event) {
        if (event.key === 'Enter') { event.preventDefault(); event.target.blur(); } else if (event.key === 'Escape') { const field = inputFieldsData.find(f => f.id === parseInt(event.target.dataset.labelId, 10)); if (field) event.target.textContent = field.label; event.target.blur(); }
    }
    function handleDeleteField(event) {
        const button = event.target.closest('button.delete-btn'); if (!button) return; const fieldIdToDelete = parseInt(button.dataset.fieldId, 10); const field = inputFieldsData.find(f => f.id === fieldIdToDelete); const labelToDelete = field ? field.label : `æ¡ç›® ${fieldIdToDelete}`; if (confirm(`ç¡®å®šè¦åˆ é™¤ "${labelToDelete}" åŠå…¶å†…å®¹å—ï¼Ÿ`)) { inputFieldsData = inputFieldsData.filter(f => f.id !== fieldIdToDelete); saveData(); renderInputFields(); }
    }
    function handleInsertFieldBelow(event) {
        const button = event.target.closest('button.insert-btn'); if (!button) return;
        const fieldIdToInsertBelow = parseInt(button.dataset.fieldId, 10);
        const index = inputFieldsData.findIndex(f => f.id === fieldIdToInsertBelow);
        if (index === -1) return;
        const newFieldId = nextId++;
        const nextItemNumber = getNextDefaultItemNumber(inputFieldsData);
        const newField = {
            id: newFieldId,
            label: `${defaultItemLabelPrefix}${nextItemNumber}:`,
            value: "",
            includeInOutput: true
        };
        inputFieldsData.splice(index + 1, 0, newField);
        saveData();
        renderInputFields();
        focusAndScrollToField(newFieldId);
    }
    function handleAddField() {
        const newFieldId = nextId++;
        const nextItemNumber = getNextDefaultItemNumber(inputFieldsData);
        const newField = {
            id: newFieldId,
            label: `${defaultItemLabelPrefix}${nextItemNumber}:`,
            value: "",
            includeInOutput: true
        };
        inputFieldsData.push(newField);
        saveData();
        renderInputFields();
        focusAndScrollToField(newFieldId);
    }
    function focusAndScrollToField(fieldId) {
        requestAnimationFrame(() => { const newGroup = inputFieldsContainer.querySelector(`.input-group[data-field-id="${fieldId}"]`); if (newGroup) { newGroup.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); const newLabel = newGroup.querySelector('label.editable-label'); if (newLabel) { setTimeout(() => { newLabel.focus(); try { const selection = window.getSelection(); const range = document.createRange(); range.selectNodeContents(newLabel); selection?.removeAllRanges(); selection?.addRange(range); } catch (e) { /* Ignore */ } }, 150); } } });
    }
    function handleTextareaInput(event) {
        const textarea = event.target; const fieldId = parseInt(textarea.id.replace('input-', ''), 10); const field = inputFieldsData.find(f => f.id === fieldId); if (field) { field.value = textarea.value; debounceSaveData(); } updateArticle();
    }
    let saveTimeout; function debounceSaveData(delay = 600) { clearTimeout(saveTimeout); saveTimeout = setTimeout(() => { saveData(); }, delay); }

    // --- Event Handler for Checkbox Change ---
    function handleIncludeCheckboxChange(event) {
        const checkbox = event.target;
        const fieldId = parseInt(checkbox.dataset.fieldId, 10);
        const field = inputFieldsData.find(f => f.id === fieldId);
        if (field) {
            field.includeInOutput = checkbox.checked;
            saveData();
            updateArticle();
        }
    }

    // --- Character Counting and Time Estimation Function ---
    function updateCharacterCounts(text) {
         let iTotal = 0, sTotal = 0, eTotal = 0, inum = 0; for (let i = 0; i < text.length; i++) { const c = text.charAt(i); if (c.match(/[\u4e00-\u9fa5]/)) { iTotal++; } if (c.match(/[^\x00-\xff]/)) { sTotal++; } else { eTotal++; } if (c.match(/[0-9]/)) { inum++; } }
         const totalChars = text.length, hanziCount = iTotal, biaodianCount = sTotal - iTotal, zimuCount = eTotal - inum, shuziCount = inum;
         statsTotalEl.textContent = totalChars; statsHanziEl.textContent = hanziCount; statsBiaodianEl.textContent = biaodianCount; statsZimuEl.textContent = zimuCount; statsShuziEl.textContent = shuziCount;
         let minutes = 0, seconds = 0; if (hanziCount > 0 && speakingRate > 0) { const totalSeconds = Math.round((hanziCount / speakingRate) * 60); minutes = Math.floor(totalSeconds / 60); seconds = totalSeconds % 60; }
         statsTimeEl.textContent = `${minutes}åˆ†${seconds}ç§’`;
    }

    // --- Core Article Update Function (Adds colon after label in preview) ---
    function updateArticle() {
        // Filter fields for VISUAL output: must be checked AND have content
        const fieldsToDisplay = inputFieldsData.filter(field => field.includeInOutput && field.value.trim() !== '');

        if (fieldsToDisplay.length === 0) {
            outputArea.innerHTML = '<div class="empty-message">æ²¡æœ‰å‹¾é€‰ä¸”æœ‰å†…å®¹çš„æ¡ç›®å¯æ˜¾ç¤º...</div>';
        } else {
            const displayContentHTML = fieldsToDisplay
                .map(field => {
                    const safeLabel = escapeHTML(field.label.replace(/:$/, '')); // Remove potential trailing colon from label itself
                    const safeValue = escapeHTML(field.value);
                    const valuePart = safeValue ? ' ' + safeValue : ''; // Add space only if value exists
                    // Add the colon directly after the label text within the <strong> tag
                    return `<div><strong>${safeLabel}:</strong>${valuePart}</div>`;
                })
                .join('');
            outputArea.innerHTML = displayContentHTML;
        }

        // Filter fields for COUNTING and COPYING: must be checked
        const fieldsToCountAndCopy = inputFieldsData.filter(field => field.includeInOutput);
        const contentForCounting = fieldsToCountAndCopy.map(field => field.value).join('\n');
        updateCharacterCounts(contentForCounting);

        // Enable/disable copy button based on whether ANY *checked* input field has a trimmed value
        const hasIncludedTrimmedValue = fieldsToCountAndCopy.some(field => field.value.trim() !== '');
        if (hasIncludedTrimmedValue) {
            if (!copyBtn.classList.contains('copied')) {
                copyBtn.textContent = 'å¤åˆ¶æ–‡ç« ';
            }
            copyBtn.disabled = false;
        } else {
            copyBtn.disabled = true;
            copyBtn.textContent = 'å¤åˆ¶æ–‡ç« ';
            copyBtn.classList.remove('copied');
        }

         // Enable/disable download button
         downloadTxtBtn.disabled = inputFieldsData.length === 0;
    }


    // --- Copy Button Logic ---
    copyBtn.addEventListener('click', () => {
        if (copyBtn.disabled || copyBtn.classList.contains('copied')) return;

        const textToCopy = inputFieldsData
            .filter(field => field.includeInOutput && field.value.trim() !== '')
            .map(field => field.value.trim())
            .join('\n');

        if (!textToCopy) { return; }

        if (!navigator.clipboard) {
            alert('æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè‡ªåŠ¨å¤åˆ¶åŠŸèƒ½ã€‚è¯·æ‰‹åŠ¨å¤åˆ¶æ‰€éœ€å†…å®¹ã€‚\n\n--- å†…å®¹å¼€å§‹ ---\n' + textToCopy + '\n--- å†…å®¹ç»“æŸ ---');
            return;
        }

        navigator.clipboard.writeText(textToCopy).then(() => {
            copyBtn.textContent = 'å·²å¤åˆ¶!';
            copyBtn.classList.add('copied');
            copyBtn.disabled = true;
            setTimeout(() => {
                copyBtn.textContent = 'å¤åˆ¶æ–‡ç« ';
                copyBtn.classList.remove('copied');
                const stillHasContentToCopy = inputFieldsData.some(field => field.includeInOutput && field.value.trim() !== '');
                copyBtn.disabled = !stillHasContentToCopy;
            }, 2000);
        }).catch(err => {
            console.error('æ— æ³•å¤åˆ¶æ–‡æœ¬: ', err);
            alert('å¤åˆ¶å¤±è´¥ï¼Œå¯èƒ½éœ€è¦æµè§ˆå™¨æƒé™ã€‚\n\nè¯·æ‰‹åŠ¨å¤åˆ¶æ‰€éœ€å†…å®¹:\n\n--- å†…å®¹å¼€å§‹ ---\n' + textToCopy + '\n--- å†…å®¹ç»“æŸ ---');
        });
    });

    // --- Download TXT Button Logic ---
    function handleDownloadTxt() {
        if (downloadTxtBtn.disabled || inputFieldsData.length === 0) return;

        // Update data from DOM just in case
        inputFieldsData.forEach(field => {
            const textarea = document.getElementById(`input-${field.id}`);
            if (textarea) field.value = textarea.value;
            const label = document.getElementById(`label-${field.id}`);
            if (label && label.textContent !== field.label) {
                 field.label = label.textContent.trim() || `æœªå‘½å ${field.id}:`;
            }
        });

        // Format: Label: Value (ensure label ends with a colon if it doesn't)
        const textContent = inputFieldsData.map(field => {
             const labelText = field.label.endsWith(':') ? field.label : field.label + ':';
             return `${labelText} ${field.value}`; // Add space between label and value
        }).join('\n\n'); // Use double newline for separation between items

        const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;

        const dateStr = new Date().toISOString().slice(0, 10);
        link.download = `article_data_${dateStr}.txt`;

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }


    // --- Event Handlers for Editable Rate Span ---
    function handleRateDblClick(event) {
        const target = event.target; target.contentEditable = 'true'; target.focus(); try { const selection = window.getSelection(); const range = document.createRange(); range.selectNodeContents(target); selection?.removeAllRanges(); selection?.addRange(range); } catch (e) { console.error("Error selecting rate text:", e); }
    }
    function handleRateBlur(event) {
         const target = event.target; const newRateText = target.textContent.trim(); let newRate = parseInt(newRateText, 10); let isValid = false; if (!isNaN(newRate) && newRate >= MIN_SPEAKING_RATE && newRate <= MAX_SPEAKING_RATE) { isValid = true; } else { if (!isNaN(newRate)) { newRate = Math.max(MIN_SPEAKING_RATE, Math.min(MAX_SPEAKING_RATE, newRate)); isValid = true; } } target.contentEditable = 'false'; if (isValid) { if (newRate !== speakingRate) { speakingRate = newRate; target.textContent = speakingRate; saveData(); updateArticle(); } else { target.textContent = speakingRate; } } else { console.warn("Invalid rate input, reverting to:", speakingRate); target.textContent = speakingRate; }
    }
    function handleRateKeydown(event) {
         if (event.key === 'Enter') { event.preventDefault(); event.target.blur(); } else if (event.key === 'Escape') { event.target.textContent = speakingRate; event.target.blur(); }
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        addFieldBtn.addEventListener('click', handleAddField);
        downloadTxtBtn.addEventListener('click', handleDownloadTxt);

        loadData();
        renderInputFields();

        statsRateValueEl.addEventListener('dblclick', handleRateDblClick);
        statsRateValueEl.addEventListener('blur', handleRateBlur);
        statsRateValueEl.addEventListener('keydown', handleRateKeydown);
    });
</script>

</body></html>